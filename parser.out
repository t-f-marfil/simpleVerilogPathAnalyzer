Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    LOCALPARAM
    LSHIFT
    RSHIFT

Grammar

Rule 0     S' -> source
Rule 1     source -> moduledec source
Rule 2     source -> empty
Rule 3     moduledec -> MODULE ID paramdec portdec ; modulecontent ENDMODULE
Rule 4     moduledec -> MODULE ID portdec ; modulecontent ENDMODULE
Rule 5     paramdec -> # ( params )
Rule 6     params -> oneparam paramplus
Rule 7     params -> empty
Rule 8     paramplus -> , oneparam paramplus
Rule 9     paramplus -> empty
Rule 10    oneparam -> PARAMETER ID = arithexpr
Rule 11    arithexpr -> NUMBER
Rule 12    portdec -> ( ports )
Rule 13    ports -> oneport portplus
Rule 14    ports -> empty
Rule 15    portplus -> , oneport portplus
Rule 16    portplus -> empty
Rule 17    oneport -> inouttype ID
Rule 18    oneport -> inouttype [ arithexpr : arithexpr ] ID
Rule 19    inouttype -> INPUT
Rule 20    inouttype -> OUTPUT
Rule 21    inouttype -> INPUT wiretype
Rule 22    inouttype -> OUTPUT wiretype
Rule 23    modulecontent -> wiredec ; modulecontent
Rule 24    modulecontent -> assign ; modulecontent
Rule 25    modulecontent -> always modulecontent
Rule 26    modulecontent -> empty
Rule 27    wiredec -> wiretype [ arithexpr : arithexpr ] ID
Rule 28    wiredec -> wiretype ID
Rule 29    wiretype -> WIRE
Rule 30    wiretype -> REG
Rule 31    wiretype -> LOGIC
Rule 32    assign -> ASSIGN lhs = wireexpr
Rule 33    always -> ALWAYS @ sensitivity alwayscontblock
Rule 34    always -> ALWAYSFF @ sensitivity alwayscontblock
Rule 35    always -> ALWAYSCOMB alwayscontblock
Rule 36    sensitivity -> ( edge ID )
Rule 37    edge -> POSEDGE
Rule 38    edge -> NEGEDGE
Rule 39    alwayscontblock -> BEGIN alwayscont END
Rule 40    alwayscont -> oneassign ; alwayscont
Rule 41    alwayscont -> ifblock alwayscont
Rule 42    alwayscont -> ifblock elseblock alwayscont
Rule 43    alwayscont -> empty
Rule 44    oneassign -> lhs = wireexpr
Rule 45    oneassign -> lhs NONBLOCK wireexpr
Rule 46    ifblock -> IF ( wireexpr ) BEGIN alwayscont END
Rule 47    elseblock -> ELSE ifblock
Rule 48    elseblock -> ELSE ifblock elseblock
Rule 49    elseblock -> ELSE BEGIN alwayscont END
Rule 50    lhs -> ID
Rule 51    lhs -> ID [ arithexpr : arithexpr ]
Rule 52    lhs -> { lhsconcat }
Rule 53    lhsconcat -> lhs
Rule 54    lhsconcat -> lhs , lhsconcat
Rule 55    wireexpr -> wireval
Rule 56    wireexpr -> wireval wireop wireexpr
Rule 57    wireexpr -> wireval ? wireexpr : wireexpr
Rule 58    wireval -> ALLHIGH
Rule 59    wireval -> ALLLOW
Rule 60    wireval -> LITWIRE
Rule 61    wireval -> { wireconcat }
Rule 62    wireval -> ( wireexpr )
Rule 63    wireval -> ID [ arithexpr : arithexpr ]
Rule 64    wireval -> ID [ arithexpr ]
Rule 65    wireval -> unaop wireval
Rule 66    unaop -> ~
Rule 67    unaop -> &
Rule 68    unaop -> ^
Rule 69    unaop -> |
Rule 70    wireval -> ID
Rule 71    wireconcat -> wireexpr
Rule 72    wireconcat -> wireexpr , wireconcat
Rule 73    wireop -> +
Rule 74    wireop -> -
Rule 75    wireop -> *
Rule 76    wireop -> &
Rule 77    wireop -> |
Rule 78    wireop -> ^
Rule 79    wireop -> <
Rule 80    wireop -> >
Rule 81    wireop -> EQ
Rule 82    wireop -> GEQ
Rule 83    wireop -> LEQ
Rule 84    empty -> <empty>

Terminals, with rules where they appear

#                    : 5
&                    : 67 76
(                    : 5 12 36 46 62
)                    : 5 12 36 46 62
*                    : 75
+                    : 73
,                    : 8 15 54 72
-                    : 74
:                    : 18 27 51 57 63
;                    : 3 4 23 24 40
<                    : 79
=                    : 10 32 44
>                    : 80
?                    : 57
@                    : 33 34
ALLHIGH              : 58
ALLLOW               : 59
ALWAYS               : 33
ALWAYSCOMB           : 35
ALWAYSFF             : 34
ASSIGN               : 32
BEGIN                : 39 46 49
ELSE                 : 47 48 49
END                  : 39 46 49
ENDMODULE            : 3 4
EQ                   : 81
GEQ                  : 82
ID                   : 3 4 10 17 18 27 28 36 50 51 63 64 70
IF                   : 46
INPUT                : 19 21
LEQ                  : 83
LITWIRE              : 60
LOCALPARAM           : 
LOGIC                : 31
LSHIFT               : 
MODULE               : 3 4
NEGEDGE              : 38
NONBLOCK             : 45
NUMBER               : 11
OUTPUT               : 20 22
PARAMETER            : 10
POSEDGE              : 37
REG                  : 30
RSHIFT               : 
WIRE                 : 29
[                    : 18 27 51 63 64
]                    : 18 27 51 63 64
^                    : 68 78
error                : 
{                    : 52 61
|                    : 69 77
}                    : 52 61
~                    : 66

Nonterminals, with rules where they appear

always               : 25
alwayscont           : 39 40 41 42 46 49
alwayscontblock      : 33 34 35
arithexpr            : 10 18 18 27 27 51 51 63 63 64
assign               : 24
edge                 : 36
elseblock            : 42 48
empty                : 2 7 9 14 16 26 43
ifblock              : 41 42 47 48
inouttype            : 17 18
lhs                  : 32 44 45 53 54
lhsconcat            : 52 54
modulecontent        : 3 4 23 24 25
moduledec            : 1
oneassign            : 40
oneparam             : 6 8
oneport              : 13 15
paramdec             : 3
paramplus            : 6 8
params               : 5
portdec              : 3 4
portplus             : 13 15
ports                : 12
sensitivity          : 33 34
source               : 1 0
unaop                : 65
wireconcat           : 61 72
wiredec              : 23
wireexpr             : 32 44 45 46 56 57 57 62 71 72
wireop               : 56
wiretype             : 21 22 27 28
wireval              : 55 56 57 65

Parsing method: LALR

state 0

    (0) S' -> . source
    (1) source -> . moduledec source
    (2) source -> . empty
    (3) moduledec -> . MODULE ID paramdec portdec ; modulecontent ENDMODULE
    (4) moduledec -> . MODULE ID portdec ; modulecontent ENDMODULE
    (84) empty -> .

    MODULE          shift and go to state 4
    $end            reduce using rule 84 (empty -> .)

    source                         shift and go to state 1
    moduledec                      shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> source .



state 2

    (1) source -> moduledec . source
    (1) source -> . moduledec source
    (2) source -> . empty
    (3) moduledec -> . MODULE ID paramdec portdec ; modulecontent ENDMODULE
    (4) moduledec -> . MODULE ID portdec ; modulecontent ENDMODULE
    (84) empty -> .

    MODULE          shift and go to state 4
    $end            reduce using rule 84 (empty -> .)

    moduledec                      shift and go to state 2
    source                         shift and go to state 5
    empty                          shift and go to state 3

state 3

    (2) source -> empty .

    $end            reduce using rule 2 (source -> empty .)


state 4

    (3) moduledec -> MODULE . ID paramdec portdec ; modulecontent ENDMODULE
    (4) moduledec -> MODULE . ID portdec ; modulecontent ENDMODULE

    ID              shift and go to state 6


state 5

    (1) source -> moduledec source .

    $end            reduce using rule 1 (source -> moduledec source .)


state 6

    (3) moduledec -> MODULE ID . paramdec portdec ; modulecontent ENDMODULE
    (4) moduledec -> MODULE ID . portdec ; modulecontent ENDMODULE
    (5) paramdec -> . # ( params )
    (12) portdec -> . ( ports )

    #               shift and go to state 9
    (               shift and go to state 10

    paramdec                       shift and go to state 7
    portdec                        shift and go to state 8

state 7

    (3) moduledec -> MODULE ID paramdec . portdec ; modulecontent ENDMODULE
    (12) portdec -> . ( ports )

    (               shift and go to state 10

    portdec                        shift and go to state 11

state 8

    (4) moduledec -> MODULE ID portdec . ; modulecontent ENDMODULE

    ;               shift and go to state 12


state 9

    (5) paramdec -> # . ( params )

    (               shift and go to state 13


state 10

    (12) portdec -> ( . ports )
    (13) ports -> . oneport portplus
    (14) ports -> . empty
    (17) oneport -> . inouttype ID
    (18) oneport -> . inouttype [ arithexpr : arithexpr ] ID
    (84) empty -> .
    (19) inouttype -> . INPUT
    (20) inouttype -> . OUTPUT
    (21) inouttype -> . INPUT wiretype
    (22) inouttype -> . OUTPUT wiretype

    )               reduce using rule 84 (empty -> .)
    INPUT           shift and go to state 18
    OUTPUT          shift and go to state 19

    ports                          shift and go to state 14
    oneport                        shift and go to state 15
    empty                          shift and go to state 16
    inouttype                      shift and go to state 17

state 11

    (3) moduledec -> MODULE ID paramdec portdec . ; modulecontent ENDMODULE

    ;               shift and go to state 20


state 12

    (4) moduledec -> MODULE ID portdec ; . modulecontent ENDMODULE
    (23) modulecontent -> . wiredec ; modulecontent
    (24) modulecontent -> . assign ; modulecontent
    (25) modulecontent -> . always modulecontent
    (26) modulecontent -> . empty
    (27) wiredec -> . wiretype [ arithexpr : arithexpr ] ID
    (28) wiredec -> . wiretype ID
    (32) assign -> . ASSIGN lhs = wireexpr
    (33) always -> . ALWAYS @ sensitivity alwayscontblock
    (34) always -> . ALWAYSFF @ sensitivity alwayscontblock
    (35) always -> . ALWAYSCOMB alwayscontblock
    (84) empty -> .
    (29) wiretype -> . WIRE
    (30) wiretype -> . REG
    (31) wiretype -> . LOGIC

    ASSIGN          shift and go to state 27
    ALWAYS          shift and go to state 28
    ALWAYSFF        shift and go to state 29
    ALWAYSCOMB      shift and go to state 30
    ENDMODULE       reduce using rule 84 (empty -> .)
    WIRE            shift and go to state 31
    REG             shift and go to state 32
    LOGIC           shift and go to state 33

    modulecontent                  shift and go to state 21
    wiredec                        shift and go to state 22
    assign                         shift and go to state 23
    always                         shift and go to state 24
    empty                          shift and go to state 25
    wiretype                       shift and go to state 26

state 13

    (5) paramdec -> # ( . params )
    (6) params -> . oneparam paramplus
    (7) params -> . empty
    (10) oneparam -> . PARAMETER ID = arithexpr
    (84) empty -> .

    PARAMETER       shift and go to state 37
    )               reduce using rule 84 (empty -> .)

    params                         shift and go to state 34
    oneparam                       shift and go to state 35
    empty                          shift and go to state 36

state 14

    (12) portdec -> ( ports . )

    )               shift and go to state 38


state 15

    (13) ports -> oneport . portplus
    (15) portplus -> . , oneport portplus
    (16) portplus -> . empty
    (84) empty -> .

    ,               shift and go to state 40
    )               reduce using rule 84 (empty -> .)

    portplus                       shift and go to state 39
    empty                          shift and go to state 41

state 16

    (14) ports -> empty .

    )               reduce using rule 14 (ports -> empty .)


state 17

    (17) oneport -> inouttype . ID
    (18) oneport -> inouttype . [ arithexpr : arithexpr ] ID

    ID              shift and go to state 42
    [               shift and go to state 43


state 18

    (19) inouttype -> INPUT .
    (21) inouttype -> INPUT . wiretype
    (29) wiretype -> . WIRE
    (30) wiretype -> . REG
    (31) wiretype -> . LOGIC

    ID              reduce using rule 19 (inouttype -> INPUT .)
    [               reduce using rule 19 (inouttype -> INPUT .)
    WIRE            shift and go to state 31
    REG             shift and go to state 32
    LOGIC           shift and go to state 33

    wiretype                       shift and go to state 44

state 19

    (20) inouttype -> OUTPUT .
    (22) inouttype -> OUTPUT . wiretype
    (29) wiretype -> . WIRE
    (30) wiretype -> . REG
    (31) wiretype -> . LOGIC

    ID              reduce using rule 20 (inouttype -> OUTPUT .)
    [               reduce using rule 20 (inouttype -> OUTPUT .)
    WIRE            shift and go to state 31
    REG             shift and go to state 32
    LOGIC           shift and go to state 33

    wiretype                       shift and go to state 45

state 20

    (3) moduledec -> MODULE ID paramdec portdec ; . modulecontent ENDMODULE
    (23) modulecontent -> . wiredec ; modulecontent
    (24) modulecontent -> . assign ; modulecontent
    (25) modulecontent -> . always modulecontent
    (26) modulecontent -> . empty
    (27) wiredec -> . wiretype [ arithexpr : arithexpr ] ID
    (28) wiredec -> . wiretype ID
    (32) assign -> . ASSIGN lhs = wireexpr
    (33) always -> . ALWAYS @ sensitivity alwayscontblock
    (34) always -> . ALWAYSFF @ sensitivity alwayscontblock
    (35) always -> . ALWAYSCOMB alwayscontblock
    (84) empty -> .
    (29) wiretype -> . WIRE
    (30) wiretype -> . REG
    (31) wiretype -> . LOGIC

    ASSIGN          shift and go to state 27
    ALWAYS          shift and go to state 28
    ALWAYSFF        shift and go to state 29
    ALWAYSCOMB      shift and go to state 30
    ENDMODULE       reduce using rule 84 (empty -> .)
    WIRE            shift and go to state 31
    REG             shift and go to state 32
    LOGIC           shift and go to state 33

    modulecontent                  shift and go to state 46
    wiredec                        shift and go to state 22
    assign                         shift and go to state 23
    always                         shift and go to state 24
    empty                          shift and go to state 25
    wiretype                       shift and go to state 26

state 21

    (4) moduledec -> MODULE ID portdec ; modulecontent . ENDMODULE

    ENDMODULE       shift and go to state 47


state 22

    (23) modulecontent -> wiredec . ; modulecontent

    ;               shift and go to state 48


state 23

    (24) modulecontent -> assign . ; modulecontent

    ;               shift and go to state 49


state 24

    (25) modulecontent -> always . modulecontent
    (23) modulecontent -> . wiredec ; modulecontent
    (24) modulecontent -> . assign ; modulecontent
    (25) modulecontent -> . always modulecontent
    (26) modulecontent -> . empty
    (27) wiredec -> . wiretype [ arithexpr : arithexpr ] ID
    (28) wiredec -> . wiretype ID
    (32) assign -> . ASSIGN lhs = wireexpr
    (33) always -> . ALWAYS @ sensitivity alwayscontblock
    (34) always -> . ALWAYSFF @ sensitivity alwayscontblock
    (35) always -> . ALWAYSCOMB alwayscontblock
    (84) empty -> .
    (29) wiretype -> . WIRE
    (30) wiretype -> . REG
    (31) wiretype -> . LOGIC

    ASSIGN          shift and go to state 27
    ALWAYS          shift and go to state 28
    ALWAYSFF        shift and go to state 29
    ALWAYSCOMB      shift and go to state 30
    ENDMODULE       reduce using rule 84 (empty -> .)
    WIRE            shift and go to state 31
    REG             shift and go to state 32
    LOGIC           shift and go to state 33

    always                         shift and go to state 24
    modulecontent                  shift and go to state 50
    wiredec                        shift and go to state 22
    assign                         shift and go to state 23
    empty                          shift and go to state 25
    wiretype                       shift and go to state 26

state 25

    (26) modulecontent -> empty .

    ENDMODULE       reduce using rule 26 (modulecontent -> empty .)


state 26

    (27) wiredec -> wiretype . [ arithexpr : arithexpr ] ID
    (28) wiredec -> wiretype . ID

    [               shift and go to state 51
    ID              shift and go to state 52


state 27

    (32) assign -> ASSIGN . lhs = wireexpr
    (50) lhs -> . ID
    (51) lhs -> . ID [ arithexpr : arithexpr ]
    (52) lhs -> . { lhsconcat }

    ID              shift and go to state 54
    {               shift and go to state 55

    lhs                            shift and go to state 53

state 28

    (33) always -> ALWAYS . @ sensitivity alwayscontblock

    @               shift and go to state 56


state 29

    (34) always -> ALWAYSFF . @ sensitivity alwayscontblock

    @               shift and go to state 57


state 30

    (35) always -> ALWAYSCOMB . alwayscontblock
    (39) alwayscontblock -> . BEGIN alwayscont END

    BEGIN           shift and go to state 59

    alwayscontblock                shift and go to state 58

state 31

    (29) wiretype -> WIRE .

    [               reduce using rule 29 (wiretype -> WIRE .)
    ID              reduce using rule 29 (wiretype -> WIRE .)


state 32

    (30) wiretype -> REG .

    [               reduce using rule 30 (wiretype -> REG .)
    ID              reduce using rule 30 (wiretype -> REG .)


state 33

    (31) wiretype -> LOGIC .

    [               reduce using rule 31 (wiretype -> LOGIC .)
    ID              reduce using rule 31 (wiretype -> LOGIC .)


state 34

    (5) paramdec -> # ( params . )

    )               shift and go to state 60


state 35

    (6) params -> oneparam . paramplus
    (8) paramplus -> . , oneparam paramplus
    (9) paramplus -> . empty
    (84) empty -> .

    ,               shift and go to state 62
    )               reduce using rule 84 (empty -> .)

    paramplus                      shift and go to state 61
    empty                          shift and go to state 63

state 36

    (7) params -> empty .

    )               reduce using rule 7 (params -> empty .)


state 37

    (10) oneparam -> PARAMETER . ID = arithexpr

    ID              shift and go to state 64


state 38

    (12) portdec -> ( ports ) .

    ;               reduce using rule 12 (portdec -> ( ports ) .)


state 39

    (13) ports -> oneport portplus .

    )               reduce using rule 13 (ports -> oneport portplus .)


state 40

    (15) portplus -> , . oneport portplus
    (17) oneport -> . inouttype ID
    (18) oneport -> . inouttype [ arithexpr : arithexpr ] ID
    (19) inouttype -> . INPUT
    (20) inouttype -> . OUTPUT
    (21) inouttype -> . INPUT wiretype
    (22) inouttype -> . OUTPUT wiretype

    INPUT           shift and go to state 18
    OUTPUT          shift and go to state 19

    oneport                        shift and go to state 65
    inouttype                      shift and go to state 17

state 41

    (16) portplus -> empty .

    )               reduce using rule 16 (portplus -> empty .)


state 42

    (17) oneport -> inouttype ID .

    ,               reduce using rule 17 (oneport -> inouttype ID .)
    )               reduce using rule 17 (oneport -> inouttype ID .)


state 43

    (18) oneport -> inouttype [ . arithexpr : arithexpr ] ID
    (11) arithexpr -> . NUMBER

    NUMBER          shift and go to state 67

    arithexpr                      shift and go to state 66

state 44

    (21) inouttype -> INPUT wiretype .

    ID              reduce using rule 21 (inouttype -> INPUT wiretype .)
    [               reduce using rule 21 (inouttype -> INPUT wiretype .)


state 45

    (22) inouttype -> OUTPUT wiretype .

    ID              reduce using rule 22 (inouttype -> OUTPUT wiretype .)
    [               reduce using rule 22 (inouttype -> OUTPUT wiretype .)


state 46

    (3) moduledec -> MODULE ID paramdec portdec ; modulecontent . ENDMODULE

    ENDMODULE       shift and go to state 68


state 47

    (4) moduledec -> MODULE ID portdec ; modulecontent ENDMODULE .

    MODULE          reduce using rule 4 (moduledec -> MODULE ID portdec ; modulecontent ENDMODULE .)
    $end            reduce using rule 4 (moduledec -> MODULE ID portdec ; modulecontent ENDMODULE .)


state 48

    (23) modulecontent -> wiredec ; . modulecontent
    (23) modulecontent -> . wiredec ; modulecontent
    (24) modulecontent -> . assign ; modulecontent
    (25) modulecontent -> . always modulecontent
    (26) modulecontent -> . empty
    (27) wiredec -> . wiretype [ arithexpr : arithexpr ] ID
    (28) wiredec -> . wiretype ID
    (32) assign -> . ASSIGN lhs = wireexpr
    (33) always -> . ALWAYS @ sensitivity alwayscontblock
    (34) always -> . ALWAYSFF @ sensitivity alwayscontblock
    (35) always -> . ALWAYSCOMB alwayscontblock
    (84) empty -> .
    (29) wiretype -> . WIRE
    (30) wiretype -> . REG
    (31) wiretype -> . LOGIC

    ASSIGN          shift and go to state 27
    ALWAYS          shift and go to state 28
    ALWAYSFF        shift and go to state 29
    ALWAYSCOMB      shift and go to state 30
    ENDMODULE       reduce using rule 84 (empty -> .)
    WIRE            shift and go to state 31
    REG             shift and go to state 32
    LOGIC           shift and go to state 33

    wiredec                        shift and go to state 22
    modulecontent                  shift and go to state 69
    assign                         shift and go to state 23
    always                         shift and go to state 24
    empty                          shift and go to state 25
    wiretype                       shift and go to state 26

state 49

    (24) modulecontent -> assign ; . modulecontent
    (23) modulecontent -> . wiredec ; modulecontent
    (24) modulecontent -> . assign ; modulecontent
    (25) modulecontent -> . always modulecontent
    (26) modulecontent -> . empty
    (27) wiredec -> . wiretype [ arithexpr : arithexpr ] ID
    (28) wiredec -> . wiretype ID
    (32) assign -> . ASSIGN lhs = wireexpr
    (33) always -> . ALWAYS @ sensitivity alwayscontblock
    (34) always -> . ALWAYSFF @ sensitivity alwayscontblock
    (35) always -> . ALWAYSCOMB alwayscontblock
    (84) empty -> .
    (29) wiretype -> . WIRE
    (30) wiretype -> . REG
    (31) wiretype -> . LOGIC

    ASSIGN          shift and go to state 27
    ALWAYS          shift and go to state 28
    ALWAYSFF        shift and go to state 29
    ALWAYSCOMB      shift and go to state 30
    ENDMODULE       reduce using rule 84 (empty -> .)
    WIRE            shift and go to state 31
    REG             shift and go to state 32
    LOGIC           shift and go to state 33

    assign                         shift and go to state 23
    modulecontent                  shift and go to state 70
    wiredec                        shift and go to state 22
    always                         shift and go to state 24
    empty                          shift and go to state 25
    wiretype                       shift and go to state 26

state 50

    (25) modulecontent -> always modulecontent .

    ENDMODULE       reduce using rule 25 (modulecontent -> always modulecontent .)


state 51

    (27) wiredec -> wiretype [ . arithexpr : arithexpr ] ID
    (11) arithexpr -> . NUMBER

    NUMBER          shift and go to state 67

    arithexpr                      shift and go to state 71

state 52

    (28) wiredec -> wiretype ID .

    ;               reduce using rule 28 (wiredec -> wiretype ID .)


state 53

    (32) assign -> ASSIGN lhs . = wireexpr

    =               shift and go to state 72


state 54

    (50) lhs -> ID .
    (51) lhs -> ID . [ arithexpr : arithexpr ]

    =               reduce using rule 50 (lhs -> ID .)
    ,               reduce using rule 50 (lhs -> ID .)
    }               reduce using rule 50 (lhs -> ID .)
    NONBLOCK        reduce using rule 50 (lhs -> ID .)
    [               shift and go to state 73


state 55

    (52) lhs -> { . lhsconcat }
    (53) lhsconcat -> . lhs
    (54) lhsconcat -> . lhs , lhsconcat
    (50) lhs -> . ID
    (51) lhs -> . ID [ arithexpr : arithexpr ]
    (52) lhs -> . { lhsconcat }

    ID              shift and go to state 54
    {               shift and go to state 55

    lhsconcat                      shift and go to state 74
    lhs                            shift and go to state 75

state 56

    (33) always -> ALWAYS @ . sensitivity alwayscontblock
    (36) sensitivity -> . ( edge ID )

    (               shift and go to state 77

    sensitivity                    shift and go to state 76

state 57

    (34) always -> ALWAYSFF @ . sensitivity alwayscontblock
    (36) sensitivity -> . ( edge ID )

    (               shift and go to state 77

    sensitivity                    shift and go to state 78

state 58

    (35) always -> ALWAYSCOMB alwayscontblock .

    ASSIGN          reduce using rule 35 (always -> ALWAYSCOMB alwayscontblock .)
    ALWAYS          reduce using rule 35 (always -> ALWAYSCOMB alwayscontblock .)
    ALWAYSFF        reduce using rule 35 (always -> ALWAYSCOMB alwayscontblock .)
    ALWAYSCOMB      reduce using rule 35 (always -> ALWAYSCOMB alwayscontblock .)
    WIRE            reduce using rule 35 (always -> ALWAYSCOMB alwayscontblock .)
    REG             reduce using rule 35 (always -> ALWAYSCOMB alwayscontblock .)
    LOGIC           reduce using rule 35 (always -> ALWAYSCOMB alwayscontblock .)
    ENDMODULE       reduce using rule 35 (always -> ALWAYSCOMB alwayscontblock .)


state 59

    (39) alwayscontblock -> BEGIN . alwayscont END
    (40) alwayscont -> . oneassign ; alwayscont
    (41) alwayscont -> . ifblock alwayscont
    (42) alwayscont -> . ifblock elseblock alwayscont
    (43) alwayscont -> . empty
    (44) oneassign -> . lhs = wireexpr
    (45) oneassign -> . lhs NONBLOCK wireexpr
    (46) ifblock -> . IF ( wireexpr ) BEGIN alwayscont END
    (84) empty -> .
    (50) lhs -> . ID
    (51) lhs -> . ID [ arithexpr : arithexpr ]
    (52) lhs -> . { lhsconcat }

    IF              shift and go to state 84
    END             reduce using rule 84 (empty -> .)
    ID              shift and go to state 54
    {               shift and go to state 55

    alwayscont                     shift and go to state 79
    oneassign                      shift and go to state 80
    ifblock                        shift and go to state 81
    empty                          shift and go to state 82
    lhs                            shift and go to state 83

state 60

    (5) paramdec -> # ( params ) .

    (               reduce using rule 5 (paramdec -> # ( params ) .)


state 61

    (6) params -> oneparam paramplus .

    )               reduce using rule 6 (params -> oneparam paramplus .)


state 62

    (8) paramplus -> , . oneparam paramplus
    (10) oneparam -> . PARAMETER ID = arithexpr

    PARAMETER       shift and go to state 37

    oneparam                       shift and go to state 85

state 63

    (9) paramplus -> empty .

    )               reduce using rule 9 (paramplus -> empty .)


state 64

    (10) oneparam -> PARAMETER ID . = arithexpr

    =               shift and go to state 86


state 65

    (15) portplus -> , oneport . portplus
    (15) portplus -> . , oneport portplus
    (16) portplus -> . empty
    (84) empty -> .

    ,               shift and go to state 40
    )               reduce using rule 84 (empty -> .)

    portplus                       shift and go to state 87
    empty                          shift and go to state 41

state 66

    (18) oneport -> inouttype [ arithexpr . : arithexpr ] ID

    :               shift and go to state 88


state 67

    (11) arithexpr -> NUMBER .

    :               reduce using rule 11 (arithexpr -> NUMBER .)
    ,               reduce using rule 11 (arithexpr -> NUMBER .)
    )               reduce using rule 11 (arithexpr -> NUMBER .)
    ]               reduce using rule 11 (arithexpr -> NUMBER .)


state 68

    (3) moduledec -> MODULE ID paramdec portdec ; modulecontent ENDMODULE .

    MODULE          reduce using rule 3 (moduledec -> MODULE ID paramdec portdec ; modulecontent ENDMODULE .)
    $end            reduce using rule 3 (moduledec -> MODULE ID paramdec portdec ; modulecontent ENDMODULE .)


state 69

    (23) modulecontent -> wiredec ; modulecontent .

    ENDMODULE       reduce using rule 23 (modulecontent -> wiredec ; modulecontent .)


state 70

    (24) modulecontent -> assign ; modulecontent .

    ENDMODULE       reduce using rule 24 (modulecontent -> assign ; modulecontent .)


state 71

    (27) wiredec -> wiretype [ arithexpr . : arithexpr ] ID

    :               shift and go to state 89


state 72

    (32) assign -> ASSIGN lhs = . wireexpr
    (55) wireexpr -> . wireval
    (56) wireexpr -> . wireval wireop wireexpr
    (57) wireexpr -> . wireval ? wireexpr : wireexpr
    (58) wireval -> . ALLHIGH
    (59) wireval -> . ALLLOW
    (60) wireval -> . LITWIRE
    (61) wireval -> . { wireconcat }
    (62) wireval -> . ( wireexpr )
    (63) wireval -> . ID [ arithexpr : arithexpr ]
    (64) wireval -> . ID [ arithexpr ]
    (65) wireval -> . unaop wireval
    (70) wireval -> . ID
    (66) unaop -> . ~
    (67) unaop -> . &
    (68) unaop -> . ^
    (69) unaop -> . |

    ALLHIGH         shift and go to state 92
    ALLLOW          shift and go to state 93
    LITWIRE         shift and go to state 94
    {               shift and go to state 95
    (               shift and go to state 96
    ID              shift and go to state 97
    ~               shift and go to state 99
    &               shift and go to state 100
    ^               shift and go to state 101
    |               shift and go to state 102

    wireexpr                       shift and go to state 90
    wireval                        shift and go to state 91
    unaop                          shift and go to state 98

state 73

    (51) lhs -> ID [ . arithexpr : arithexpr ]
    (11) arithexpr -> . NUMBER

    NUMBER          shift and go to state 67

    arithexpr                      shift and go to state 103

state 74

    (52) lhs -> { lhsconcat . }

    }               shift and go to state 104


state 75

    (53) lhsconcat -> lhs .
    (54) lhsconcat -> lhs . , lhsconcat

    }               reduce using rule 53 (lhsconcat -> lhs .)
    ,               shift and go to state 105


state 76

    (33) always -> ALWAYS @ sensitivity . alwayscontblock
    (39) alwayscontblock -> . BEGIN alwayscont END

    BEGIN           shift and go to state 59

    alwayscontblock                shift and go to state 106

state 77

    (36) sensitivity -> ( . edge ID )
    (37) edge -> . POSEDGE
    (38) edge -> . NEGEDGE

    POSEDGE         shift and go to state 108
    NEGEDGE         shift and go to state 109

    edge                           shift and go to state 107

state 78

    (34) always -> ALWAYSFF @ sensitivity . alwayscontblock
    (39) alwayscontblock -> . BEGIN alwayscont END

    BEGIN           shift and go to state 59

    alwayscontblock                shift and go to state 110

state 79

    (39) alwayscontblock -> BEGIN alwayscont . END

    END             shift and go to state 111


state 80

    (40) alwayscont -> oneassign . ; alwayscont

    ;               shift and go to state 112


state 81

    (41) alwayscont -> ifblock . alwayscont
    (42) alwayscont -> ifblock . elseblock alwayscont
    (40) alwayscont -> . oneassign ; alwayscont
    (41) alwayscont -> . ifblock alwayscont
    (42) alwayscont -> . ifblock elseblock alwayscont
    (43) alwayscont -> . empty
    (47) elseblock -> . ELSE ifblock
    (48) elseblock -> . ELSE ifblock elseblock
    (49) elseblock -> . ELSE BEGIN alwayscont END
    (44) oneassign -> . lhs = wireexpr
    (45) oneassign -> . lhs NONBLOCK wireexpr
    (46) ifblock -> . IF ( wireexpr ) BEGIN alwayscont END
    (84) empty -> .
    (50) lhs -> . ID
    (51) lhs -> . ID [ arithexpr : arithexpr ]
    (52) lhs -> . { lhsconcat }

    ELSE            shift and go to state 115
    IF              shift and go to state 84
    END             reduce using rule 84 (empty -> .)
    ID              shift and go to state 54
    {               shift and go to state 55

    ifblock                        shift and go to state 81
    alwayscont                     shift and go to state 113
    elseblock                      shift and go to state 114
    oneassign                      shift and go to state 80
    empty                          shift and go to state 82
    lhs                            shift and go to state 83

state 82

    (43) alwayscont -> empty .

    END             reduce using rule 43 (alwayscont -> empty .)


state 83

    (44) oneassign -> lhs . = wireexpr
    (45) oneassign -> lhs . NONBLOCK wireexpr

    =               shift and go to state 116
    NONBLOCK        shift and go to state 117


state 84

    (46) ifblock -> IF . ( wireexpr ) BEGIN alwayscont END

    (               shift and go to state 118


state 85

    (8) paramplus -> , oneparam . paramplus
    (8) paramplus -> . , oneparam paramplus
    (9) paramplus -> . empty
    (84) empty -> .

    ,               shift and go to state 62
    )               reduce using rule 84 (empty -> .)

    paramplus                      shift and go to state 119
    empty                          shift and go to state 63

state 86

    (10) oneparam -> PARAMETER ID = . arithexpr
    (11) arithexpr -> . NUMBER

    NUMBER          shift and go to state 67

    arithexpr                      shift and go to state 120

state 87

    (15) portplus -> , oneport portplus .

    )               reduce using rule 15 (portplus -> , oneport portplus .)


state 88

    (18) oneport -> inouttype [ arithexpr : . arithexpr ] ID
    (11) arithexpr -> . NUMBER

    NUMBER          shift and go to state 67

    arithexpr                      shift and go to state 121

state 89

    (27) wiredec -> wiretype [ arithexpr : . arithexpr ] ID
    (11) arithexpr -> . NUMBER

    NUMBER          shift and go to state 67

    arithexpr                      shift and go to state 122

state 90

    (32) assign -> ASSIGN lhs = wireexpr .

    ;               reduce using rule 32 (assign -> ASSIGN lhs = wireexpr .)


state 91

    (55) wireexpr -> wireval .
    (56) wireexpr -> wireval . wireop wireexpr
    (57) wireexpr -> wireval . ? wireexpr : wireexpr
    (73) wireop -> . +
    (74) wireop -> . -
    (75) wireop -> . *
    (76) wireop -> . &
    (77) wireop -> . |
    (78) wireop -> . ^
    (79) wireop -> . <
    (80) wireop -> . >
    (81) wireop -> . EQ
    (82) wireop -> . GEQ
    (83) wireop -> . LEQ

    ;               reduce using rule 55 (wireexpr -> wireval .)
    ,               reduce using rule 55 (wireexpr -> wireval .)
    }               reduce using rule 55 (wireexpr -> wireval .)
    )               reduce using rule 55 (wireexpr -> wireval .)
    :               reduce using rule 55 (wireexpr -> wireval .)
    ?               shift and go to state 124
    +               shift and go to state 125
    -               shift and go to state 126
    *               shift and go to state 127
    &               shift and go to state 128
    |               shift and go to state 129
    ^               shift and go to state 130
    <               shift and go to state 131
    >               shift and go to state 132
    EQ              shift and go to state 133
    GEQ             shift and go to state 134
    LEQ             shift and go to state 135

    wireop                         shift and go to state 123

state 92

    (58) wireval -> ALLHIGH .

    ?               reduce using rule 58 (wireval -> ALLHIGH .)
    +               reduce using rule 58 (wireval -> ALLHIGH .)
    -               reduce using rule 58 (wireval -> ALLHIGH .)
    *               reduce using rule 58 (wireval -> ALLHIGH .)
    &               reduce using rule 58 (wireval -> ALLHIGH .)
    |               reduce using rule 58 (wireval -> ALLHIGH .)
    ^               reduce using rule 58 (wireval -> ALLHIGH .)
    <               reduce using rule 58 (wireval -> ALLHIGH .)
    >               reduce using rule 58 (wireval -> ALLHIGH .)
    EQ              reduce using rule 58 (wireval -> ALLHIGH .)
    GEQ             reduce using rule 58 (wireval -> ALLHIGH .)
    LEQ             reduce using rule 58 (wireval -> ALLHIGH .)
    ;               reduce using rule 58 (wireval -> ALLHIGH .)
    ,               reduce using rule 58 (wireval -> ALLHIGH .)
    }               reduce using rule 58 (wireval -> ALLHIGH .)
    )               reduce using rule 58 (wireval -> ALLHIGH .)
    :               reduce using rule 58 (wireval -> ALLHIGH .)


state 93

    (59) wireval -> ALLLOW .

    ?               reduce using rule 59 (wireval -> ALLLOW .)
    +               reduce using rule 59 (wireval -> ALLLOW .)
    -               reduce using rule 59 (wireval -> ALLLOW .)
    *               reduce using rule 59 (wireval -> ALLLOW .)
    &               reduce using rule 59 (wireval -> ALLLOW .)
    |               reduce using rule 59 (wireval -> ALLLOW .)
    ^               reduce using rule 59 (wireval -> ALLLOW .)
    <               reduce using rule 59 (wireval -> ALLLOW .)
    >               reduce using rule 59 (wireval -> ALLLOW .)
    EQ              reduce using rule 59 (wireval -> ALLLOW .)
    GEQ             reduce using rule 59 (wireval -> ALLLOW .)
    LEQ             reduce using rule 59 (wireval -> ALLLOW .)
    ;               reduce using rule 59 (wireval -> ALLLOW .)
    ,               reduce using rule 59 (wireval -> ALLLOW .)
    }               reduce using rule 59 (wireval -> ALLLOW .)
    )               reduce using rule 59 (wireval -> ALLLOW .)
    :               reduce using rule 59 (wireval -> ALLLOW .)


state 94

    (60) wireval -> LITWIRE .

    ?               reduce using rule 60 (wireval -> LITWIRE .)
    +               reduce using rule 60 (wireval -> LITWIRE .)
    -               reduce using rule 60 (wireval -> LITWIRE .)
    *               reduce using rule 60 (wireval -> LITWIRE .)
    &               reduce using rule 60 (wireval -> LITWIRE .)
    |               reduce using rule 60 (wireval -> LITWIRE .)
    ^               reduce using rule 60 (wireval -> LITWIRE .)
    <               reduce using rule 60 (wireval -> LITWIRE .)
    >               reduce using rule 60 (wireval -> LITWIRE .)
    EQ              reduce using rule 60 (wireval -> LITWIRE .)
    GEQ             reduce using rule 60 (wireval -> LITWIRE .)
    LEQ             reduce using rule 60 (wireval -> LITWIRE .)
    ;               reduce using rule 60 (wireval -> LITWIRE .)
    ,               reduce using rule 60 (wireval -> LITWIRE .)
    }               reduce using rule 60 (wireval -> LITWIRE .)
    )               reduce using rule 60 (wireval -> LITWIRE .)
    :               reduce using rule 60 (wireval -> LITWIRE .)


state 95

    (61) wireval -> { . wireconcat }
    (71) wireconcat -> . wireexpr
    (72) wireconcat -> . wireexpr , wireconcat
    (55) wireexpr -> . wireval
    (56) wireexpr -> . wireval wireop wireexpr
    (57) wireexpr -> . wireval ? wireexpr : wireexpr
    (58) wireval -> . ALLHIGH
    (59) wireval -> . ALLLOW
    (60) wireval -> . LITWIRE
    (61) wireval -> . { wireconcat }
    (62) wireval -> . ( wireexpr )
    (63) wireval -> . ID [ arithexpr : arithexpr ]
    (64) wireval -> . ID [ arithexpr ]
    (65) wireval -> . unaop wireval
    (70) wireval -> . ID
    (66) unaop -> . ~
    (67) unaop -> . &
    (68) unaop -> . ^
    (69) unaop -> . |

    ALLHIGH         shift and go to state 92
    ALLLOW          shift and go to state 93
    LITWIRE         shift and go to state 94
    {               shift and go to state 95
    (               shift and go to state 96
    ID              shift and go to state 97
    ~               shift and go to state 99
    &               shift and go to state 100
    ^               shift and go to state 101
    |               shift and go to state 102

    wireconcat                     shift and go to state 136
    wireexpr                       shift and go to state 137
    wireval                        shift and go to state 91
    unaop                          shift and go to state 98

state 96

    (62) wireval -> ( . wireexpr )
    (55) wireexpr -> . wireval
    (56) wireexpr -> . wireval wireop wireexpr
    (57) wireexpr -> . wireval ? wireexpr : wireexpr
    (58) wireval -> . ALLHIGH
    (59) wireval -> . ALLLOW
    (60) wireval -> . LITWIRE
    (61) wireval -> . { wireconcat }
    (62) wireval -> . ( wireexpr )
    (63) wireval -> . ID [ arithexpr : arithexpr ]
    (64) wireval -> . ID [ arithexpr ]
    (65) wireval -> . unaop wireval
    (70) wireval -> . ID
    (66) unaop -> . ~
    (67) unaop -> . &
    (68) unaop -> . ^
    (69) unaop -> . |

    ALLHIGH         shift and go to state 92
    ALLLOW          shift and go to state 93
    LITWIRE         shift and go to state 94
    {               shift and go to state 95
    (               shift and go to state 96
    ID              shift and go to state 97
    ~               shift and go to state 99
    &               shift and go to state 100
    ^               shift and go to state 101
    |               shift and go to state 102

    wireexpr                       shift and go to state 138
    wireval                        shift and go to state 91
    unaop                          shift and go to state 98

state 97

    (63) wireval -> ID . [ arithexpr : arithexpr ]
    (64) wireval -> ID . [ arithexpr ]
    (70) wireval -> ID .

    [               shift and go to state 139
    ?               reduce using rule 70 (wireval -> ID .)
    +               reduce using rule 70 (wireval -> ID .)
    -               reduce using rule 70 (wireval -> ID .)
    *               reduce using rule 70 (wireval -> ID .)
    &               reduce using rule 70 (wireval -> ID .)
    |               reduce using rule 70 (wireval -> ID .)
    ^               reduce using rule 70 (wireval -> ID .)
    <               reduce using rule 70 (wireval -> ID .)
    >               reduce using rule 70 (wireval -> ID .)
    EQ              reduce using rule 70 (wireval -> ID .)
    GEQ             reduce using rule 70 (wireval -> ID .)
    LEQ             reduce using rule 70 (wireval -> ID .)
    ;               reduce using rule 70 (wireval -> ID .)
    ,               reduce using rule 70 (wireval -> ID .)
    }               reduce using rule 70 (wireval -> ID .)
    )               reduce using rule 70 (wireval -> ID .)
    :               reduce using rule 70 (wireval -> ID .)


state 98

    (65) wireval -> unaop . wireval
    (58) wireval -> . ALLHIGH
    (59) wireval -> . ALLLOW
    (60) wireval -> . LITWIRE
    (61) wireval -> . { wireconcat }
    (62) wireval -> . ( wireexpr )
    (63) wireval -> . ID [ arithexpr : arithexpr ]
    (64) wireval -> . ID [ arithexpr ]
    (65) wireval -> . unaop wireval
    (70) wireval -> . ID
    (66) unaop -> . ~
    (67) unaop -> . &
    (68) unaop -> . ^
    (69) unaop -> . |

    ALLHIGH         shift and go to state 92
    ALLLOW          shift and go to state 93
    LITWIRE         shift and go to state 94
    {               shift and go to state 95
    (               shift and go to state 96
    ID              shift and go to state 97
    ~               shift and go to state 99
    &               shift and go to state 100
    ^               shift and go to state 101
    |               shift and go to state 102

    unaop                          shift and go to state 98
    wireval                        shift and go to state 140

state 99

    (66) unaop -> ~ .

    ALLHIGH         reduce using rule 66 (unaop -> ~ .)
    ALLLOW          reduce using rule 66 (unaop -> ~ .)
    LITWIRE         reduce using rule 66 (unaop -> ~ .)
    {               reduce using rule 66 (unaop -> ~ .)
    (               reduce using rule 66 (unaop -> ~ .)
    ID              reduce using rule 66 (unaop -> ~ .)
    ~               reduce using rule 66 (unaop -> ~ .)
    &               reduce using rule 66 (unaop -> ~ .)
    ^               reduce using rule 66 (unaop -> ~ .)
    |               reduce using rule 66 (unaop -> ~ .)


state 100

    (67) unaop -> & .

    ALLHIGH         reduce using rule 67 (unaop -> & .)
    ALLLOW          reduce using rule 67 (unaop -> & .)
    LITWIRE         reduce using rule 67 (unaop -> & .)
    {               reduce using rule 67 (unaop -> & .)
    (               reduce using rule 67 (unaop -> & .)
    ID              reduce using rule 67 (unaop -> & .)
    ~               reduce using rule 67 (unaop -> & .)
    &               reduce using rule 67 (unaop -> & .)
    ^               reduce using rule 67 (unaop -> & .)
    |               reduce using rule 67 (unaop -> & .)


state 101

    (68) unaop -> ^ .

    ALLHIGH         reduce using rule 68 (unaop -> ^ .)
    ALLLOW          reduce using rule 68 (unaop -> ^ .)
    LITWIRE         reduce using rule 68 (unaop -> ^ .)
    {               reduce using rule 68 (unaop -> ^ .)
    (               reduce using rule 68 (unaop -> ^ .)
    ID              reduce using rule 68 (unaop -> ^ .)
    ~               reduce using rule 68 (unaop -> ^ .)
    &               reduce using rule 68 (unaop -> ^ .)
    ^               reduce using rule 68 (unaop -> ^ .)
    |               reduce using rule 68 (unaop -> ^ .)


state 102

    (69) unaop -> | .

    ALLHIGH         reduce using rule 69 (unaop -> | .)
    ALLLOW          reduce using rule 69 (unaop -> | .)
    LITWIRE         reduce using rule 69 (unaop -> | .)
    {               reduce using rule 69 (unaop -> | .)
    (               reduce using rule 69 (unaop -> | .)
    ID              reduce using rule 69 (unaop -> | .)
    ~               reduce using rule 69 (unaop -> | .)
    &               reduce using rule 69 (unaop -> | .)
    ^               reduce using rule 69 (unaop -> | .)
    |               reduce using rule 69 (unaop -> | .)


state 103

    (51) lhs -> ID [ arithexpr . : arithexpr ]

    :               shift and go to state 141


state 104

    (52) lhs -> { lhsconcat } .

    =               reduce using rule 52 (lhs -> { lhsconcat } .)
    ,               reduce using rule 52 (lhs -> { lhsconcat } .)
    }               reduce using rule 52 (lhs -> { lhsconcat } .)
    NONBLOCK        reduce using rule 52 (lhs -> { lhsconcat } .)


state 105

    (54) lhsconcat -> lhs , . lhsconcat
    (53) lhsconcat -> . lhs
    (54) lhsconcat -> . lhs , lhsconcat
    (50) lhs -> . ID
    (51) lhs -> . ID [ arithexpr : arithexpr ]
    (52) lhs -> . { lhsconcat }

    ID              shift and go to state 54
    {               shift and go to state 55

    lhs                            shift and go to state 75
    lhsconcat                      shift and go to state 142

state 106

    (33) always -> ALWAYS @ sensitivity alwayscontblock .

    ASSIGN          reduce using rule 33 (always -> ALWAYS @ sensitivity alwayscontblock .)
    ALWAYS          reduce using rule 33 (always -> ALWAYS @ sensitivity alwayscontblock .)
    ALWAYSFF        reduce using rule 33 (always -> ALWAYS @ sensitivity alwayscontblock .)
    ALWAYSCOMB      reduce using rule 33 (always -> ALWAYS @ sensitivity alwayscontblock .)
    WIRE            reduce using rule 33 (always -> ALWAYS @ sensitivity alwayscontblock .)
    REG             reduce using rule 33 (always -> ALWAYS @ sensitivity alwayscontblock .)
    LOGIC           reduce using rule 33 (always -> ALWAYS @ sensitivity alwayscontblock .)
    ENDMODULE       reduce using rule 33 (always -> ALWAYS @ sensitivity alwayscontblock .)


state 107

    (36) sensitivity -> ( edge . ID )

    ID              shift and go to state 143


state 108

    (37) edge -> POSEDGE .

    ID              reduce using rule 37 (edge -> POSEDGE .)


state 109

    (38) edge -> NEGEDGE .

    ID              reduce using rule 38 (edge -> NEGEDGE .)


state 110

    (34) always -> ALWAYSFF @ sensitivity alwayscontblock .

    ASSIGN          reduce using rule 34 (always -> ALWAYSFF @ sensitivity alwayscontblock .)
    ALWAYS          reduce using rule 34 (always -> ALWAYSFF @ sensitivity alwayscontblock .)
    ALWAYSFF        reduce using rule 34 (always -> ALWAYSFF @ sensitivity alwayscontblock .)
    ALWAYSCOMB      reduce using rule 34 (always -> ALWAYSFF @ sensitivity alwayscontblock .)
    WIRE            reduce using rule 34 (always -> ALWAYSFF @ sensitivity alwayscontblock .)
    REG             reduce using rule 34 (always -> ALWAYSFF @ sensitivity alwayscontblock .)
    LOGIC           reduce using rule 34 (always -> ALWAYSFF @ sensitivity alwayscontblock .)
    ENDMODULE       reduce using rule 34 (always -> ALWAYSFF @ sensitivity alwayscontblock .)


state 111

    (39) alwayscontblock -> BEGIN alwayscont END .

    ASSIGN          reduce using rule 39 (alwayscontblock -> BEGIN alwayscont END .)
    ALWAYS          reduce using rule 39 (alwayscontblock -> BEGIN alwayscont END .)
    ALWAYSFF        reduce using rule 39 (alwayscontblock -> BEGIN alwayscont END .)
    ALWAYSCOMB      reduce using rule 39 (alwayscontblock -> BEGIN alwayscont END .)
    WIRE            reduce using rule 39 (alwayscontblock -> BEGIN alwayscont END .)
    REG             reduce using rule 39 (alwayscontblock -> BEGIN alwayscont END .)
    LOGIC           reduce using rule 39 (alwayscontblock -> BEGIN alwayscont END .)
    ENDMODULE       reduce using rule 39 (alwayscontblock -> BEGIN alwayscont END .)


state 112

    (40) alwayscont -> oneassign ; . alwayscont
    (40) alwayscont -> . oneassign ; alwayscont
    (41) alwayscont -> . ifblock alwayscont
    (42) alwayscont -> . ifblock elseblock alwayscont
    (43) alwayscont -> . empty
    (44) oneassign -> . lhs = wireexpr
    (45) oneassign -> . lhs NONBLOCK wireexpr
    (46) ifblock -> . IF ( wireexpr ) BEGIN alwayscont END
    (84) empty -> .
    (50) lhs -> . ID
    (51) lhs -> . ID [ arithexpr : arithexpr ]
    (52) lhs -> . { lhsconcat }

    IF              shift and go to state 84
    END             reduce using rule 84 (empty -> .)
    ID              shift and go to state 54
    {               shift and go to state 55

    oneassign                      shift and go to state 80
    alwayscont                     shift and go to state 144
    ifblock                        shift and go to state 81
    empty                          shift and go to state 82
    lhs                            shift and go to state 83

state 113

    (41) alwayscont -> ifblock alwayscont .

    END             reduce using rule 41 (alwayscont -> ifblock alwayscont .)


state 114

    (42) alwayscont -> ifblock elseblock . alwayscont
    (40) alwayscont -> . oneassign ; alwayscont
    (41) alwayscont -> . ifblock alwayscont
    (42) alwayscont -> . ifblock elseblock alwayscont
    (43) alwayscont -> . empty
    (44) oneassign -> . lhs = wireexpr
    (45) oneassign -> . lhs NONBLOCK wireexpr
    (46) ifblock -> . IF ( wireexpr ) BEGIN alwayscont END
    (84) empty -> .
    (50) lhs -> . ID
    (51) lhs -> . ID [ arithexpr : arithexpr ]
    (52) lhs -> . { lhsconcat }

    IF              shift and go to state 84
    END             reduce using rule 84 (empty -> .)
    ID              shift and go to state 54
    {               shift and go to state 55

    ifblock                        shift and go to state 81
    alwayscont                     shift and go to state 145
    oneassign                      shift and go to state 80
    empty                          shift and go to state 82
    lhs                            shift and go to state 83

state 115

    (47) elseblock -> ELSE . ifblock
    (48) elseblock -> ELSE . ifblock elseblock
    (49) elseblock -> ELSE . BEGIN alwayscont END
    (46) ifblock -> . IF ( wireexpr ) BEGIN alwayscont END

    BEGIN           shift and go to state 147
    IF              shift and go to state 84

    ifblock                        shift and go to state 146

state 116

    (44) oneassign -> lhs = . wireexpr
    (55) wireexpr -> . wireval
    (56) wireexpr -> . wireval wireop wireexpr
    (57) wireexpr -> . wireval ? wireexpr : wireexpr
    (58) wireval -> . ALLHIGH
    (59) wireval -> . ALLLOW
    (60) wireval -> . LITWIRE
    (61) wireval -> . { wireconcat }
    (62) wireval -> . ( wireexpr )
    (63) wireval -> . ID [ arithexpr : arithexpr ]
    (64) wireval -> . ID [ arithexpr ]
    (65) wireval -> . unaop wireval
    (70) wireval -> . ID
    (66) unaop -> . ~
    (67) unaop -> . &
    (68) unaop -> . ^
    (69) unaop -> . |

    ALLHIGH         shift and go to state 92
    ALLLOW          shift and go to state 93
    LITWIRE         shift and go to state 94
    {               shift and go to state 95
    (               shift and go to state 96
    ID              shift and go to state 97
    ~               shift and go to state 99
    &               shift and go to state 100
    ^               shift and go to state 101
    |               shift and go to state 102

    wireexpr                       shift and go to state 148
    wireval                        shift and go to state 91
    unaop                          shift and go to state 98

state 117

    (45) oneassign -> lhs NONBLOCK . wireexpr
    (55) wireexpr -> . wireval
    (56) wireexpr -> . wireval wireop wireexpr
    (57) wireexpr -> . wireval ? wireexpr : wireexpr
    (58) wireval -> . ALLHIGH
    (59) wireval -> . ALLLOW
    (60) wireval -> . LITWIRE
    (61) wireval -> . { wireconcat }
    (62) wireval -> . ( wireexpr )
    (63) wireval -> . ID [ arithexpr : arithexpr ]
    (64) wireval -> . ID [ arithexpr ]
    (65) wireval -> . unaop wireval
    (70) wireval -> . ID
    (66) unaop -> . ~
    (67) unaop -> . &
    (68) unaop -> . ^
    (69) unaop -> . |

    ALLHIGH         shift and go to state 92
    ALLLOW          shift and go to state 93
    LITWIRE         shift and go to state 94
    {               shift and go to state 95
    (               shift and go to state 96
    ID              shift and go to state 97
    ~               shift and go to state 99
    &               shift and go to state 100
    ^               shift and go to state 101
    |               shift and go to state 102

    wireexpr                       shift and go to state 149
    wireval                        shift and go to state 91
    unaop                          shift and go to state 98

state 118

    (46) ifblock -> IF ( . wireexpr ) BEGIN alwayscont END
    (55) wireexpr -> . wireval
    (56) wireexpr -> . wireval wireop wireexpr
    (57) wireexpr -> . wireval ? wireexpr : wireexpr
    (58) wireval -> . ALLHIGH
    (59) wireval -> . ALLLOW
    (60) wireval -> . LITWIRE
    (61) wireval -> . { wireconcat }
    (62) wireval -> . ( wireexpr )
    (63) wireval -> . ID [ arithexpr : arithexpr ]
    (64) wireval -> . ID [ arithexpr ]
    (65) wireval -> . unaop wireval
    (70) wireval -> . ID
    (66) unaop -> . ~
    (67) unaop -> . &
    (68) unaop -> . ^
    (69) unaop -> . |

    ALLHIGH         shift and go to state 92
    ALLLOW          shift and go to state 93
    LITWIRE         shift and go to state 94
    {               shift and go to state 95
    (               shift and go to state 96
    ID              shift and go to state 97
    ~               shift and go to state 99
    &               shift and go to state 100
    ^               shift and go to state 101
    |               shift and go to state 102

    wireexpr                       shift and go to state 150
    wireval                        shift and go to state 91
    unaop                          shift and go to state 98

state 119

    (8) paramplus -> , oneparam paramplus .

    )               reduce using rule 8 (paramplus -> , oneparam paramplus .)


state 120

    (10) oneparam -> PARAMETER ID = arithexpr .

    ,               reduce using rule 10 (oneparam -> PARAMETER ID = arithexpr .)
    )               reduce using rule 10 (oneparam -> PARAMETER ID = arithexpr .)


state 121

    (18) oneport -> inouttype [ arithexpr : arithexpr . ] ID

    ]               shift and go to state 151


state 122

    (27) wiredec -> wiretype [ arithexpr : arithexpr . ] ID

    ]               shift and go to state 152


state 123

    (56) wireexpr -> wireval wireop . wireexpr
    (55) wireexpr -> . wireval
    (56) wireexpr -> . wireval wireop wireexpr
    (57) wireexpr -> . wireval ? wireexpr : wireexpr
    (58) wireval -> . ALLHIGH
    (59) wireval -> . ALLLOW
    (60) wireval -> . LITWIRE
    (61) wireval -> . { wireconcat }
    (62) wireval -> . ( wireexpr )
    (63) wireval -> . ID [ arithexpr : arithexpr ]
    (64) wireval -> . ID [ arithexpr ]
    (65) wireval -> . unaop wireval
    (70) wireval -> . ID
    (66) unaop -> . ~
    (67) unaop -> . &
    (68) unaop -> . ^
    (69) unaop -> . |

    ALLHIGH         shift and go to state 92
    ALLLOW          shift and go to state 93
    LITWIRE         shift and go to state 94
    {               shift and go to state 95
    (               shift and go to state 96
    ID              shift and go to state 97
    ~               shift and go to state 99
    &               shift and go to state 100
    ^               shift and go to state 101
    |               shift and go to state 102

    wireval                        shift and go to state 91
    wireexpr                       shift and go to state 153
    unaop                          shift and go to state 98

state 124

    (57) wireexpr -> wireval ? . wireexpr : wireexpr
    (55) wireexpr -> . wireval
    (56) wireexpr -> . wireval wireop wireexpr
    (57) wireexpr -> . wireval ? wireexpr : wireexpr
    (58) wireval -> . ALLHIGH
    (59) wireval -> . ALLLOW
    (60) wireval -> . LITWIRE
    (61) wireval -> . { wireconcat }
    (62) wireval -> . ( wireexpr )
    (63) wireval -> . ID [ arithexpr : arithexpr ]
    (64) wireval -> . ID [ arithexpr ]
    (65) wireval -> . unaop wireval
    (70) wireval -> . ID
    (66) unaop -> . ~
    (67) unaop -> . &
    (68) unaop -> . ^
    (69) unaop -> . |

    ALLHIGH         shift and go to state 92
    ALLLOW          shift and go to state 93
    LITWIRE         shift and go to state 94
    {               shift and go to state 95
    (               shift and go to state 96
    ID              shift and go to state 97
    ~               shift and go to state 99
    &               shift and go to state 100
    ^               shift and go to state 101
    |               shift and go to state 102

    wireval                        shift and go to state 91
    wireexpr                       shift and go to state 154
    unaop                          shift and go to state 98

state 125

    (73) wireop -> + .

    ALLHIGH         reduce using rule 73 (wireop -> + .)
    ALLLOW          reduce using rule 73 (wireop -> + .)
    LITWIRE         reduce using rule 73 (wireop -> + .)
    {               reduce using rule 73 (wireop -> + .)
    (               reduce using rule 73 (wireop -> + .)
    ID              reduce using rule 73 (wireop -> + .)
    ~               reduce using rule 73 (wireop -> + .)
    &               reduce using rule 73 (wireop -> + .)
    ^               reduce using rule 73 (wireop -> + .)
    |               reduce using rule 73 (wireop -> + .)


state 126

    (74) wireop -> - .

    ALLHIGH         reduce using rule 74 (wireop -> - .)
    ALLLOW          reduce using rule 74 (wireop -> - .)
    LITWIRE         reduce using rule 74 (wireop -> - .)
    {               reduce using rule 74 (wireop -> - .)
    (               reduce using rule 74 (wireop -> - .)
    ID              reduce using rule 74 (wireop -> - .)
    ~               reduce using rule 74 (wireop -> - .)
    &               reduce using rule 74 (wireop -> - .)
    ^               reduce using rule 74 (wireop -> - .)
    |               reduce using rule 74 (wireop -> - .)


state 127

    (75) wireop -> * .

    ALLHIGH         reduce using rule 75 (wireop -> * .)
    ALLLOW          reduce using rule 75 (wireop -> * .)
    LITWIRE         reduce using rule 75 (wireop -> * .)
    {               reduce using rule 75 (wireop -> * .)
    (               reduce using rule 75 (wireop -> * .)
    ID              reduce using rule 75 (wireop -> * .)
    ~               reduce using rule 75 (wireop -> * .)
    &               reduce using rule 75 (wireop -> * .)
    ^               reduce using rule 75 (wireop -> * .)
    |               reduce using rule 75 (wireop -> * .)


state 128

    (76) wireop -> & .

    ALLHIGH         reduce using rule 76 (wireop -> & .)
    ALLLOW          reduce using rule 76 (wireop -> & .)
    LITWIRE         reduce using rule 76 (wireop -> & .)
    {               reduce using rule 76 (wireop -> & .)
    (               reduce using rule 76 (wireop -> & .)
    ID              reduce using rule 76 (wireop -> & .)
    ~               reduce using rule 76 (wireop -> & .)
    &               reduce using rule 76 (wireop -> & .)
    ^               reduce using rule 76 (wireop -> & .)
    |               reduce using rule 76 (wireop -> & .)


state 129

    (77) wireop -> | .

    ALLHIGH         reduce using rule 77 (wireop -> | .)
    ALLLOW          reduce using rule 77 (wireop -> | .)
    LITWIRE         reduce using rule 77 (wireop -> | .)
    {               reduce using rule 77 (wireop -> | .)
    (               reduce using rule 77 (wireop -> | .)
    ID              reduce using rule 77 (wireop -> | .)
    ~               reduce using rule 77 (wireop -> | .)
    &               reduce using rule 77 (wireop -> | .)
    ^               reduce using rule 77 (wireop -> | .)
    |               reduce using rule 77 (wireop -> | .)


state 130

    (78) wireop -> ^ .

    ALLHIGH         reduce using rule 78 (wireop -> ^ .)
    ALLLOW          reduce using rule 78 (wireop -> ^ .)
    LITWIRE         reduce using rule 78 (wireop -> ^ .)
    {               reduce using rule 78 (wireop -> ^ .)
    (               reduce using rule 78 (wireop -> ^ .)
    ID              reduce using rule 78 (wireop -> ^ .)
    ~               reduce using rule 78 (wireop -> ^ .)
    &               reduce using rule 78 (wireop -> ^ .)
    ^               reduce using rule 78 (wireop -> ^ .)
    |               reduce using rule 78 (wireop -> ^ .)


state 131

    (79) wireop -> < .

    ALLHIGH         reduce using rule 79 (wireop -> < .)
    ALLLOW          reduce using rule 79 (wireop -> < .)
    LITWIRE         reduce using rule 79 (wireop -> < .)
    {               reduce using rule 79 (wireop -> < .)
    (               reduce using rule 79 (wireop -> < .)
    ID              reduce using rule 79 (wireop -> < .)
    ~               reduce using rule 79 (wireop -> < .)
    &               reduce using rule 79 (wireop -> < .)
    ^               reduce using rule 79 (wireop -> < .)
    |               reduce using rule 79 (wireop -> < .)


state 132

    (80) wireop -> > .

    ALLHIGH         reduce using rule 80 (wireop -> > .)
    ALLLOW          reduce using rule 80 (wireop -> > .)
    LITWIRE         reduce using rule 80 (wireop -> > .)
    {               reduce using rule 80 (wireop -> > .)
    (               reduce using rule 80 (wireop -> > .)
    ID              reduce using rule 80 (wireop -> > .)
    ~               reduce using rule 80 (wireop -> > .)
    &               reduce using rule 80 (wireop -> > .)
    ^               reduce using rule 80 (wireop -> > .)
    |               reduce using rule 80 (wireop -> > .)


state 133

    (81) wireop -> EQ .

    ALLHIGH         reduce using rule 81 (wireop -> EQ .)
    ALLLOW          reduce using rule 81 (wireop -> EQ .)
    LITWIRE         reduce using rule 81 (wireop -> EQ .)
    {               reduce using rule 81 (wireop -> EQ .)
    (               reduce using rule 81 (wireop -> EQ .)
    ID              reduce using rule 81 (wireop -> EQ .)
    ~               reduce using rule 81 (wireop -> EQ .)
    &               reduce using rule 81 (wireop -> EQ .)
    ^               reduce using rule 81 (wireop -> EQ .)
    |               reduce using rule 81 (wireop -> EQ .)


state 134

    (82) wireop -> GEQ .

    ALLHIGH         reduce using rule 82 (wireop -> GEQ .)
    ALLLOW          reduce using rule 82 (wireop -> GEQ .)
    LITWIRE         reduce using rule 82 (wireop -> GEQ .)
    {               reduce using rule 82 (wireop -> GEQ .)
    (               reduce using rule 82 (wireop -> GEQ .)
    ID              reduce using rule 82 (wireop -> GEQ .)
    ~               reduce using rule 82 (wireop -> GEQ .)
    &               reduce using rule 82 (wireop -> GEQ .)
    ^               reduce using rule 82 (wireop -> GEQ .)
    |               reduce using rule 82 (wireop -> GEQ .)


state 135

    (83) wireop -> LEQ .

    ALLHIGH         reduce using rule 83 (wireop -> LEQ .)
    ALLLOW          reduce using rule 83 (wireop -> LEQ .)
    LITWIRE         reduce using rule 83 (wireop -> LEQ .)
    {               reduce using rule 83 (wireop -> LEQ .)
    (               reduce using rule 83 (wireop -> LEQ .)
    ID              reduce using rule 83 (wireop -> LEQ .)
    ~               reduce using rule 83 (wireop -> LEQ .)
    &               reduce using rule 83 (wireop -> LEQ .)
    ^               reduce using rule 83 (wireop -> LEQ .)
    |               reduce using rule 83 (wireop -> LEQ .)


state 136

    (61) wireval -> { wireconcat . }

    }               shift and go to state 155


state 137

    (71) wireconcat -> wireexpr .
    (72) wireconcat -> wireexpr . , wireconcat

    }               reduce using rule 71 (wireconcat -> wireexpr .)
    ,               shift and go to state 156


state 138

    (62) wireval -> ( wireexpr . )

    )               shift and go to state 157


state 139

    (63) wireval -> ID [ . arithexpr : arithexpr ]
    (64) wireval -> ID [ . arithexpr ]
    (11) arithexpr -> . NUMBER

    NUMBER          shift and go to state 67

    arithexpr                      shift and go to state 158

state 140

    (65) wireval -> unaop wireval .

    ?               reduce using rule 65 (wireval -> unaop wireval .)
    +               reduce using rule 65 (wireval -> unaop wireval .)
    -               reduce using rule 65 (wireval -> unaop wireval .)
    *               reduce using rule 65 (wireval -> unaop wireval .)
    &               reduce using rule 65 (wireval -> unaop wireval .)
    |               reduce using rule 65 (wireval -> unaop wireval .)
    ^               reduce using rule 65 (wireval -> unaop wireval .)
    <               reduce using rule 65 (wireval -> unaop wireval .)
    >               reduce using rule 65 (wireval -> unaop wireval .)
    EQ              reduce using rule 65 (wireval -> unaop wireval .)
    GEQ             reduce using rule 65 (wireval -> unaop wireval .)
    LEQ             reduce using rule 65 (wireval -> unaop wireval .)
    ;               reduce using rule 65 (wireval -> unaop wireval .)
    ,               reduce using rule 65 (wireval -> unaop wireval .)
    }               reduce using rule 65 (wireval -> unaop wireval .)
    )               reduce using rule 65 (wireval -> unaop wireval .)
    :               reduce using rule 65 (wireval -> unaop wireval .)


state 141

    (51) lhs -> ID [ arithexpr : . arithexpr ]
    (11) arithexpr -> . NUMBER

    NUMBER          shift and go to state 67

    arithexpr                      shift and go to state 159

state 142

    (54) lhsconcat -> lhs , lhsconcat .

    }               reduce using rule 54 (lhsconcat -> lhs , lhsconcat .)


state 143

    (36) sensitivity -> ( edge ID . )

    )               shift and go to state 160


state 144

    (40) alwayscont -> oneassign ; alwayscont .

    END             reduce using rule 40 (alwayscont -> oneassign ; alwayscont .)


state 145

    (42) alwayscont -> ifblock elseblock alwayscont .

    END             reduce using rule 42 (alwayscont -> ifblock elseblock alwayscont .)


state 146

    (47) elseblock -> ELSE ifblock .
    (48) elseblock -> ELSE ifblock . elseblock
    (47) elseblock -> . ELSE ifblock
    (48) elseblock -> . ELSE ifblock elseblock
    (49) elseblock -> . ELSE BEGIN alwayscont END

    IF              reduce using rule 47 (elseblock -> ELSE ifblock .)
    ID              reduce using rule 47 (elseblock -> ELSE ifblock .)
    {               reduce using rule 47 (elseblock -> ELSE ifblock .)
    END             reduce using rule 47 (elseblock -> ELSE ifblock .)
    ELSE            shift and go to state 115

    elseblock                      shift and go to state 161

state 147

    (49) elseblock -> ELSE BEGIN . alwayscont END
    (40) alwayscont -> . oneassign ; alwayscont
    (41) alwayscont -> . ifblock alwayscont
    (42) alwayscont -> . ifblock elseblock alwayscont
    (43) alwayscont -> . empty
    (44) oneassign -> . lhs = wireexpr
    (45) oneassign -> . lhs NONBLOCK wireexpr
    (46) ifblock -> . IF ( wireexpr ) BEGIN alwayscont END
    (84) empty -> .
    (50) lhs -> . ID
    (51) lhs -> . ID [ arithexpr : arithexpr ]
    (52) lhs -> . { lhsconcat }

    IF              shift and go to state 84
    END             reduce using rule 84 (empty -> .)
    ID              shift and go to state 54
    {               shift and go to state 55

    alwayscont                     shift and go to state 162
    oneassign                      shift and go to state 80
    ifblock                        shift and go to state 81
    empty                          shift and go to state 82
    lhs                            shift and go to state 83

state 148

    (44) oneassign -> lhs = wireexpr .

    ;               reduce using rule 44 (oneassign -> lhs = wireexpr .)


state 149

    (45) oneassign -> lhs NONBLOCK wireexpr .

    ;               reduce using rule 45 (oneassign -> lhs NONBLOCK wireexpr .)


state 150

    (46) ifblock -> IF ( wireexpr . ) BEGIN alwayscont END

    )               shift and go to state 163


state 151

    (18) oneport -> inouttype [ arithexpr : arithexpr ] . ID

    ID              shift and go to state 164


state 152

    (27) wiredec -> wiretype [ arithexpr : arithexpr ] . ID

    ID              shift and go to state 165


state 153

    (56) wireexpr -> wireval wireop wireexpr .

    ;               reduce using rule 56 (wireexpr -> wireval wireop wireexpr .)
    ,               reduce using rule 56 (wireexpr -> wireval wireop wireexpr .)
    }               reduce using rule 56 (wireexpr -> wireval wireop wireexpr .)
    )               reduce using rule 56 (wireexpr -> wireval wireop wireexpr .)
    :               reduce using rule 56 (wireexpr -> wireval wireop wireexpr .)


state 154

    (57) wireexpr -> wireval ? wireexpr . : wireexpr

    :               shift and go to state 166


state 155

    (61) wireval -> { wireconcat } .

    ?               reduce using rule 61 (wireval -> { wireconcat } .)
    +               reduce using rule 61 (wireval -> { wireconcat } .)
    -               reduce using rule 61 (wireval -> { wireconcat } .)
    *               reduce using rule 61 (wireval -> { wireconcat } .)
    &               reduce using rule 61 (wireval -> { wireconcat } .)
    |               reduce using rule 61 (wireval -> { wireconcat } .)
    ^               reduce using rule 61 (wireval -> { wireconcat } .)
    <               reduce using rule 61 (wireval -> { wireconcat } .)
    >               reduce using rule 61 (wireval -> { wireconcat } .)
    EQ              reduce using rule 61 (wireval -> { wireconcat } .)
    GEQ             reduce using rule 61 (wireval -> { wireconcat } .)
    LEQ             reduce using rule 61 (wireval -> { wireconcat } .)
    ;               reduce using rule 61 (wireval -> { wireconcat } .)
    ,               reduce using rule 61 (wireval -> { wireconcat } .)
    }               reduce using rule 61 (wireval -> { wireconcat } .)
    )               reduce using rule 61 (wireval -> { wireconcat } .)
    :               reduce using rule 61 (wireval -> { wireconcat } .)


state 156

    (72) wireconcat -> wireexpr , . wireconcat
    (71) wireconcat -> . wireexpr
    (72) wireconcat -> . wireexpr , wireconcat
    (55) wireexpr -> . wireval
    (56) wireexpr -> . wireval wireop wireexpr
    (57) wireexpr -> . wireval ? wireexpr : wireexpr
    (58) wireval -> . ALLHIGH
    (59) wireval -> . ALLLOW
    (60) wireval -> . LITWIRE
    (61) wireval -> . { wireconcat }
    (62) wireval -> . ( wireexpr )
    (63) wireval -> . ID [ arithexpr : arithexpr ]
    (64) wireval -> . ID [ arithexpr ]
    (65) wireval -> . unaop wireval
    (70) wireval -> . ID
    (66) unaop -> . ~
    (67) unaop -> . &
    (68) unaop -> . ^
    (69) unaop -> . |

    ALLHIGH         shift and go to state 92
    ALLLOW          shift and go to state 93
    LITWIRE         shift and go to state 94
    {               shift and go to state 95
    (               shift and go to state 96
    ID              shift and go to state 97
    ~               shift and go to state 99
    &               shift and go to state 100
    ^               shift and go to state 101
    |               shift and go to state 102

    wireexpr                       shift and go to state 137
    wireconcat                     shift and go to state 167
    wireval                        shift and go to state 91
    unaop                          shift and go to state 98

state 157

    (62) wireval -> ( wireexpr ) .

    ?               reduce using rule 62 (wireval -> ( wireexpr ) .)
    +               reduce using rule 62 (wireval -> ( wireexpr ) .)
    -               reduce using rule 62 (wireval -> ( wireexpr ) .)
    *               reduce using rule 62 (wireval -> ( wireexpr ) .)
    &               reduce using rule 62 (wireval -> ( wireexpr ) .)
    |               reduce using rule 62 (wireval -> ( wireexpr ) .)
    ^               reduce using rule 62 (wireval -> ( wireexpr ) .)
    <               reduce using rule 62 (wireval -> ( wireexpr ) .)
    >               reduce using rule 62 (wireval -> ( wireexpr ) .)
    EQ              reduce using rule 62 (wireval -> ( wireexpr ) .)
    GEQ             reduce using rule 62 (wireval -> ( wireexpr ) .)
    LEQ             reduce using rule 62 (wireval -> ( wireexpr ) .)
    ;               reduce using rule 62 (wireval -> ( wireexpr ) .)
    ,               reduce using rule 62 (wireval -> ( wireexpr ) .)
    }               reduce using rule 62 (wireval -> ( wireexpr ) .)
    )               reduce using rule 62 (wireval -> ( wireexpr ) .)
    :               reduce using rule 62 (wireval -> ( wireexpr ) .)


state 158

    (63) wireval -> ID [ arithexpr . : arithexpr ]
    (64) wireval -> ID [ arithexpr . ]

    :               shift and go to state 168
    ]               shift and go to state 169


state 159

    (51) lhs -> ID [ arithexpr : arithexpr . ]

    ]               shift and go to state 170


state 160

    (36) sensitivity -> ( edge ID ) .

    BEGIN           reduce using rule 36 (sensitivity -> ( edge ID ) .)


state 161

    (48) elseblock -> ELSE ifblock elseblock .

    IF              reduce using rule 48 (elseblock -> ELSE ifblock elseblock .)
    ID              reduce using rule 48 (elseblock -> ELSE ifblock elseblock .)
    {               reduce using rule 48 (elseblock -> ELSE ifblock elseblock .)
    END             reduce using rule 48 (elseblock -> ELSE ifblock elseblock .)


state 162

    (49) elseblock -> ELSE BEGIN alwayscont . END

    END             shift and go to state 171


state 163

    (46) ifblock -> IF ( wireexpr ) . BEGIN alwayscont END

    BEGIN           shift and go to state 172


state 164

    (18) oneport -> inouttype [ arithexpr : arithexpr ] ID .

    ,               reduce using rule 18 (oneport -> inouttype [ arithexpr : arithexpr ] ID .)
    )               reduce using rule 18 (oneport -> inouttype [ arithexpr : arithexpr ] ID .)


state 165

    (27) wiredec -> wiretype [ arithexpr : arithexpr ] ID .

    ;               reduce using rule 27 (wiredec -> wiretype [ arithexpr : arithexpr ] ID .)


state 166

    (57) wireexpr -> wireval ? wireexpr : . wireexpr
    (55) wireexpr -> . wireval
    (56) wireexpr -> . wireval wireop wireexpr
    (57) wireexpr -> . wireval ? wireexpr : wireexpr
    (58) wireval -> . ALLHIGH
    (59) wireval -> . ALLLOW
    (60) wireval -> . LITWIRE
    (61) wireval -> . { wireconcat }
    (62) wireval -> . ( wireexpr )
    (63) wireval -> . ID [ arithexpr : arithexpr ]
    (64) wireval -> . ID [ arithexpr ]
    (65) wireval -> . unaop wireval
    (70) wireval -> . ID
    (66) unaop -> . ~
    (67) unaop -> . &
    (68) unaop -> . ^
    (69) unaop -> . |

    ALLHIGH         shift and go to state 92
    ALLLOW          shift and go to state 93
    LITWIRE         shift and go to state 94
    {               shift and go to state 95
    (               shift and go to state 96
    ID              shift and go to state 97
    ~               shift and go to state 99
    &               shift and go to state 100
    ^               shift and go to state 101
    |               shift and go to state 102

    wireval                        shift and go to state 91
    wireexpr                       shift and go to state 173
    unaop                          shift and go to state 98

state 167

    (72) wireconcat -> wireexpr , wireconcat .

    }               reduce using rule 72 (wireconcat -> wireexpr , wireconcat .)


state 168

    (63) wireval -> ID [ arithexpr : . arithexpr ]
    (11) arithexpr -> . NUMBER

    NUMBER          shift and go to state 67

    arithexpr                      shift and go to state 174

state 169

    (64) wireval -> ID [ arithexpr ] .

    ?               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    +               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    -               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    *               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    &               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    |               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    ^               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    <               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    >               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    EQ              reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    GEQ             reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    LEQ             reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    ;               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    ,               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    }               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    )               reduce using rule 64 (wireval -> ID [ arithexpr ] .)
    :               reduce using rule 64 (wireval -> ID [ arithexpr ] .)


state 170

    (51) lhs -> ID [ arithexpr : arithexpr ] .

    =               reduce using rule 51 (lhs -> ID [ arithexpr : arithexpr ] .)
    ,               reduce using rule 51 (lhs -> ID [ arithexpr : arithexpr ] .)
    }               reduce using rule 51 (lhs -> ID [ arithexpr : arithexpr ] .)
    NONBLOCK        reduce using rule 51 (lhs -> ID [ arithexpr : arithexpr ] .)


state 171

    (49) elseblock -> ELSE BEGIN alwayscont END .

    IF              reduce using rule 49 (elseblock -> ELSE BEGIN alwayscont END .)
    ID              reduce using rule 49 (elseblock -> ELSE BEGIN alwayscont END .)
    {               reduce using rule 49 (elseblock -> ELSE BEGIN alwayscont END .)
    END             reduce using rule 49 (elseblock -> ELSE BEGIN alwayscont END .)


state 172

    (46) ifblock -> IF ( wireexpr ) BEGIN . alwayscont END
    (40) alwayscont -> . oneassign ; alwayscont
    (41) alwayscont -> . ifblock alwayscont
    (42) alwayscont -> . ifblock elseblock alwayscont
    (43) alwayscont -> . empty
    (44) oneassign -> . lhs = wireexpr
    (45) oneassign -> . lhs NONBLOCK wireexpr
    (46) ifblock -> . IF ( wireexpr ) BEGIN alwayscont END
    (84) empty -> .
    (50) lhs -> . ID
    (51) lhs -> . ID [ arithexpr : arithexpr ]
    (52) lhs -> . { lhsconcat }

    IF              shift and go to state 84
    END             reduce using rule 84 (empty -> .)
    ID              shift and go to state 54
    {               shift and go to state 55

    alwayscont                     shift and go to state 175
    oneassign                      shift and go to state 80
    ifblock                        shift and go to state 81
    empty                          shift and go to state 82
    lhs                            shift and go to state 83

state 173

    (57) wireexpr -> wireval ? wireexpr : wireexpr .

    ;               reduce using rule 57 (wireexpr -> wireval ? wireexpr : wireexpr .)
    ,               reduce using rule 57 (wireexpr -> wireval ? wireexpr : wireexpr .)
    }               reduce using rule 57 (wireexpr -> wireval ? wireexpr : wireexpr .)
    )               reduce using rule 57 (wireexpr -> wireval ? wireexpr : wireexpr .)
    :               reduce using rule 57 (wireexpr -> wireval ? wireexpr : wireexpr .)


state 174

    (63) wireval -> ID [ arithexpr : arithexpr . ]

    ]               shift and go to state 176


state 175

    (46) ifblock -> IF ( wireexpr ) BEGIN alwayscont . END

    END             shift and go to state 177


state 176

    (63) wireval -> ID [ arithexpr : arithexpr ] .

    ?               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    +               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    -               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    *               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    &               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    |               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    ^               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    <               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    >               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    EQ              reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    GEQ             reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    LEQ             reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    ;               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    ,               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    }               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    )               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)
    :               reduce using rule 63 (wireval -> ID [ arithexpr : arithexpr ] .)


state 177

    (46) ifblock -> IF ( wireexpr ) BEGIN alwayscont END .

    ELSE            reduce using rule 46 (ifblock -> IF ( wireexpr ) BEGIN alwayscont END .)
    IF              reduce using rule 46 (ifblock -> IF ( wireexpr ) BEGIN alwayscont END .)
    ID              reduce using rule 46 (ifblock -> IF ( wireexpr ) BEGIN alwayscont END .)
    {               reduce using rule 46 (ifblock -> IF ( wireexpr ) BEGIN alwayscont END .)
    END             reduce using rule 46 (ifblock -> IF ( wireexpr ) BEGIN alwayscont END .)

